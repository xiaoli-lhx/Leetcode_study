# Hash总结

> 哈希表（`map`）最强大的地方在于它能提供**近乎 O(1) 复杂度**的快速查找、插入和删除。这使得它成为优化算法时间复杂度的“神器”。

我们可以把常见的哈希问题分为 **4 种核心模式**。

---

## 模式一：计数器模式 (The Counter)

这是哈希表最基础也是最常见的用法之一。当你需要**统计集合中每个元素出现的次数**时，就应该立刻想到它。

- **核心结构**: `map[元素类型]int`
  - `key` 是你要统计的元素。
  - `value` 是这个元素出现的次数。
- **经典例题**: **LC 169. 多数元素**
  - **问题**: 找到一个数组中出现次数超过 `⌊ n/2 ⌋` 的元素。
  - **哈希解法**:
    1. 创建一个 `map`，比如 `counts := make(map[int]int)`。
    2. 遍历数组 `nums`，对于每一个数字 `num`，执行 `counts[num]++`，给它的计数加一。
    3. 在增加计数的过程中，随时检查 `counts[num]` 是否已经大于 `len(nums)/2`。如果是，那么 `num` 就是答案。

**总结**: 这个模式是你解决所有“频率问题”的瑞士军刀。比如“找到出现次数最多的 K 个元素”、“判断两个字符串包含的字符及数量是否完全相同” (`LC 242. 有效的字母异位词`) 等问题，都离不开计数器模式。

---

## 模式二：索引配对模式 (The Index Matchmaker)

当你需要**寻找两个元素**，而这两个元素需要满足某种**数值关系**（比如它们的和、差、积等于一个特定值）时，这个模式就是你的秘密武器。

- **核心思想**: 我们在遍历数组时，不仅仅是简单地“看”每个数字，而是边看边“记录”。我们用哈希表来记录**我们见过的数字 (key) 和它的位置 (value)**。这样，对于当前正在检查的数字 `x`，我们就可以快速地去“查表”，看看我们需要的“另一半”`y` 之前是否出现过。
- **核心结构**: `map[数字类型]索引类型` -> `map[int]int`
- **经典例题**: **LC 1. 两数之和**
  - **问题**: 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那**两个**整数，并返回它们的数组下标。
  - **暴力解法**: 用双层循环，一个个数地去凑，时间复杂度是 O(n²)。
  - **哈希解法 (O(n))**:
    1. 创建一个 `map`，比如 `seen := make(map[int]int)`，用来存放**数字**和它的**下标**。
    2. 遍历数组 `nums`，对于当前下标为 `i` 的数字 `num`：
    3. 计算出我们需要的“另一半”：`complement = target - num`。
    4. **去 `map` 里查**：`complement` 这个数字我们之前见过吗？如果 `idx, ok := seen[complement]; ok`，说明我们找到了！`idx` 和当前的 `i` 就是答案。
    5. 如果没找到，就把**当前这个数字和它的下标**存入 `map`：`seen[num] = i`，以便后面的数字来和它配对。

**总结**: 这个模式的精髓在于“**边走边记录，回头快速查**”。它把寻找配对的过程从 O(n) 的搜索，变成了一次 O(1) 的哈希查找，从而把整个算法的复杂度从 O(n²) 降到了 O(n)。

---

## 模式三：特征分组模式 (The Feature Grouper)

在 **LC 49. 字母异位词分组** 中当你需要**将具有某种共同“隐藏”特征的元素归为一类**时，这个模式就派上用场了。

- **核心思想**: 我们需要创造性地为每个元素生成一个能代表其核心特征的**“身份证”**（也就是 `map` 的 `key`）。所有具有相同“身份证”的元素，自然就被分到了一组。
- **如何应用**:
  1. **识别特征**: 首先问自己：“这组东西的共同点是什么？” 对于字母异位词，共同点是“组成的字母和数量完全一样”。
  2. **制造“身份证” (Key)**: 接下来问：“我怎么才能把这个共同点变成一个独一无二的字符串或数字？”
     - **方法A (排序)**: `eat` -> 排序 -> `aet`
     - **方法B (计数)**: `eat` -> 统计 -> `a1e1t1...`
  3. **分组 (Value)**: 将原始元素放入对应“身份证”的篮子里（通常是一个列表或切片）。

**总结**: 这个模式的强大之处在于“抽象化”。它把一个看似复杂模糊的“分组”问题，转化成了一个清晰的“制造身份证”的问题。

---

## 模式四：集合存在模式 (The Set Membership Checker)

在 **LC 128. 最长连续序列** 中,它的核心作用是**优化时间复杂度**，通过“空间换时间”的策略，将查找操作从 O(n) 或 O(log n) 降到 O(1)。

- **核心思想**: 当你的算法需要**反复、快速地判断“某个东西在不在这里面？”**时，就应该使用哈希集合（在Go中用 `map[T]bool` 实现）。
- **如何应用**:
  1. **预处理/登记**: 先用 O(n) 的时间遍历一遍所有元素，把它们全部放进一个哈希集合中，就像建立一份“花名册”。
  2. **快速查询**: 在主逻辑中，每当需要判断一个元素是否存在时，直接查询哈希集合。
  3. **优化体现**: 在“最长连续序列”中，我们正是通过快速查询 `num-1` 是否存在，来巧妙地避免了 O(n log n) 的排序，也避免了对每个数字都进行重复的序列搜索。

**总结**: 这个模式是算法优化的利器。当你发现自己的解法里有嵌套循环，并且内层循环是在做一个“查找”或“判断存在”的操作时，就要立刻思考：“我能不能用哈希集合来优化掉内层循环？”